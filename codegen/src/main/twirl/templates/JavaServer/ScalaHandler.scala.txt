@*
 * Copyright (C) 2018-2024 Lightbend Inc. <https://www.lightbend.com>
 *@

@(service: akka.grpc.gen.javadsl.Service)

@akka.grpc.gen.Constants.DoNotEditComment
package @service.packageName;

import java.util.Iterator;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.Optional;

import scala.Function1;
import scala.PartialFunction;
import scala.concurrent.Future;

import akka.japi.function.Function;
import akka.actor.ActorSystem;
import akka.actor.ClassicActorSystemProvider;
import akka.annotation.ApiMayChange;
import akka.stream.Materializer;
import akka.stream.SystemMaterializer;

import akka.grpc.Trailers;
import akka.grpc.javadsl.GrpcMarshalling;
import akka.grpc.javadsl.GrpcExceptionHandler;
import akka.grpc.internal.TelemetryExtension;
import akka.grpc.internal.TelemetrySpi;
import akka.grpc.internal.InstancePerRequestPF;
import akka.grpc.scaladsl.InstancePerRequestFactory;

import akka.grpc.AkkaGrpcGenerated;

import static @{service.packageName}.@{service.name}.Serializers.*;

@*
 * Internal abstraction for Akka gRPC integration in Akka SDK.
 * Only generated for Java services, when the codegen option generateScalaHandlerFactory is set.
 *@

@defining(service.name) { serviceName =>
/*
 * Generated by Akka gRPC. DO NOT EDIT.
 *
 * The API of this class may still change in future Akka gRPC versions, see for instance
 * https://github.com/akka/akka-grpc/issues/994
 */
@@ApiMayChange

@@AkkaGrpcGenerated
public final class @{serviceName}ScalaHandlerFactory implements InstancePerRequestFactory<@{serviceName}> {

    private static final CompletionStage<akka.http.javadsl.model.HttpResponse> notFound = CompletableFuture.completedFuture(
      akka.http.javadsl.model.HttpResponse.create().withStatus(akka.http.javadsl.model.StatusCodes.NOT_FOUND));

    private static final CompletionStage<akka.http.javadsl.model.HttpResponse> unsupportedMediaType = CompletableFuture.completedFuture(
      akka.http.javadsl.model.HttpResponse.create().withStatus(akka.http.javadsl.model.StatusCodes.UNSUPPORTED_MEDIA_TYPE));


  /**
     * Creates a `HttpRequest` to `HttpResponse` handler that can be used in for example
     * `Http.get(system).bindAndHandleAsync`. It ends with `StatusCodes.NotFound` if the request is not matching.
     *
     * Use {@@link akka.grpc.javadsl.ServiceHandler#concatOrNotFound} when combining several services.
     */
  @@SuppressWarnings("All")
  @@Override
  public PartialFunction<akka.http.scaladsl.model.HttpRequest, Future<akka.http.scaladsl.model.HttpResponse>> partialInstancePerRequest(Function1<akka.http.scaladsl.model.HttpRequest, @{serviceName}> serviceFactory, String prefix, PartialFunction<Throwable, Trailers> eHandler, ClassicActorSystemProvider systemProvider) {
      InstancePerRequestPF.GrpcMethod[] methods = {
        new InstancePerRequestPF.GrpcMethod<@{serviceName}>(
          "@service.methods.head.grpcName",
          this::@{service.methods.head.name})
          @for(method <- service.methods.tail) {
            ,
            new InstancePerRequestPF.GrpcMethod<@{serviceName}>(
              "@{method.grpcName}",
              this::@{method.name})
          }
      };

      return new InstancePerRequestPF<@{serviceName}>(
          serviceFactory,
          prefix,
          methods,
          eHandler,
          systemProvider
      );
  }

    public String getServiceName() {
      return @{service.name}.name;
    }

     @for(method <- service.methods) {
       private CompletionStage<akka.http.javadsl.model.HttpResponse> @{method.name}(@{serviceName} instance, akka.japi.Function<akka.actor.ActorSystem,akka.japi.Function<java.lang.Throwable,akka.grpc.Trailers>> eHandler, Materializer mat, ClassicActorSystemProvider systemProvider, akka.http.javadsl.model.HttpRequest request) {
         return GrpcMarshalling.negotiated(request, (reader, writer) -> {
           final CompletionStage<akka.http.javadsl.model.HttpResponse> response =
              @{method.unmarshal}(request.entity(), @method.deserializer.name, mat, reader)
              .@{if(method.outputStreaming) { "thenApply" } else { "thenCompose" }}(e -> instance.@{method.name}(e))
              .thenApply(e -> @{method.marshal}(e, @method.serializer.name, writer, systemProvider.classicSystem(), eHandler));

            // note, the other impls cover the Not implemented with the ehandler as well
            return response.exceptionally(e -> GrpcExceptionHandler.standard(e, eHandler, writer, systemProvider.classicSystem()));
         }).orElseGet(() -> unsupportedMediaType);
       }
     }
  }
}
