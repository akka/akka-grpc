@*
 * Copyright (C) 2018-2025 Lightbend Inc. <https://www.lightbend.com>
 *@

@(service: akka.grpc.gen.javadsl.Service)

@akka.grpc.gen.Constants.DoNotEditComment
package @service.packageName;

import java.util.Iterator;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.Optional;

import scala.Function1;
import scala.PartialFunction;
import scala.concurrent.Future;

import akka.japi.function.Function;
import akka.actor.ActorSystem;
import akka.actor.ClassicActorSystemProvider;
import akka.annotation.ApiMayChange;
import akka.stream.Materializer;
import akka.stream.SystemMaterializer;

import akka.grpc.Trailers;
import akka.grpc.javadsl.GrpcMarshalling;
import akka.grpc.javadsl.GrpcExceptionHandler;
import akka.grpc.internal.TelemetryExtension;
import akka.grpc.internal.TelemetrySpi;
import akka.grpc.internal.InstancePerRequestPF;
import akka.grpc.scaladsl.InstancePerRequestFactory;

import akka.grpc.AkkaGrpcGenerated;

import static @{service.packageName}.@{service.name}.Serializers.*;

@*
 * Internal abstraction for Akka gRPC integration in Akka SDK.
 * Only generated for Java services, when the codegen option generateScalaHandlerFactory is set.
 *@

@defining(service.name) { serviceName =>
/*
 * Generated by Akka gRPC. DO NOT EDIT.
 *
 * The API of this class may still change in future Akka gRPC versions, see for instance
 * https://github.com/akka/akka-grpc/issues/994
 */
@@ApiMayChange

@@AkkaGrpcGenerated
public final class @{serviceName}ScalaHandlerFactory implements InstancePerRequestFactory<@{serviceName}> {

    private static final CompletionStage<akka.http.javadsl.model.HttpResponse> notFound = CompletableFuture.completedFuture(
      akka.http.javadsl.model.HttpResponse.create().withStatus(akka.http.javadsl.model.StatusCodes.NOT_FOUND));

    private static final CompletionStage<akka.http.javadsl.model.HttpResponse> unsupportedMediaType = CompletableFuture.completedFuture(
      akka.http.javadsl.model.HttpResponse.create().withStatus(akka.http.javadsl.model.StatusCodes.UNSUPPORTED_MEDIA_TYPE));

    /**
     * Creates a `HttpRequest` to `HttpResponse` handler that can be used in for example
     * `Http.get(system).bindAndHandleAsync`. It ends with `StatusCodes.NotFound` if the request is not matching.
     *
     * Use {@@link akka.grpc.javadsl.ServiceHandler#concatOrNotFound} when combining several services.
     */
    @@Override
    @@SuppressWarnings({"all","unchecked"})
    public PartialFunction<akka.http.scaladsl.model.HttpRequest, Future<akka.http.scaladsl.model.HttpResponse>> partialInstancePerRequest(Function1<akka.http.scaladsl.model.HttpRequest, @{serviceName}> serviceFactory, String prefix, PartialFunction<Throwable, Trailers> eHandler, ClassicActorSystemProvider systemProvider, Materializer materializer) {
        InstancePerRequestPF.GrpcMethod[] methods = {
          new InstancePerRequestPF.GrpcMethod<@{serviceName}>(
            "@service.methods.head.grpcName",
            this::@{service.methods.head.name})
            @for(method <- service.methods.tail) {
              ,
              new InstancePerRequestPF.GrpcMethod<@{serviceName}>(
                "@{method.grpcName}",
                this::@{method.name})
            }
        };

        return new InstancePerRequestPF<@{serviceName}>(
            serviceFactory,
            prefix,
            methods,
            eHandler,
            systemProvider,
            materializer
        );
    }

    public String getServiceName() {
      return @{service.name}.name;
    }

     @for(method <- service.methods) {
       private CompletionStage<akka.http.javadsl.model.HttpResponse> @{method.name}(@{serviceName} instance, akka.japi.Function<akka.actor.ActorSystem,akka.japi.Function<java.lang.Throwable,akka.grpc.Trailers>> eHandler, Materializer mat, ClassicActorSystemProvider systemProvider, akka.http.javadsl.model.HttpRequest request) {
         return GrpcMarshalling.negotiated(request, (reader, writer) -> {
           final CompletionStage<akka.http.javadsl.model.HttpResponse> response =
              @{method.unmarshal}(request.entity(), @method.deserializer.name, mat, reader)
              .@{if(method.outputStreaming || !method.asyncReturnValue) { "thenApplyAsync" } else { "thenComposeAsync" }}(e -> instance.@{method.name}(e), mat.executionContext())
              .thenApply(e -> @{method.marshal}(e, @method.serializer.name, writer, systemProvider.classicSystem(), eHandler));

            // note, the other impls cover the Not implemented with the ehandler as well
            return response.exceptionally(e -> GrpcExceptionHandler.standard(e, eHandler, writer, systemProvider.classicSystem()));
         }).orElseGet(() -> unsupportedMediaType);
       }
     }
  }
}
