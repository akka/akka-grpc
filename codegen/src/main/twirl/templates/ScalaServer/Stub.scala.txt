@(service: akka.http.grpc.Service)

package @service.packageName

import java.io.{ ByteArrayInputStream, ByteArrayOutputStream, InputStream }
import akka.stream.scaladsl.Source
import com.trueaccord.scalapb.grpc.Grpc
import io.grpc._
import io.grpc.stub.ClientCalls
import akka.http.grpc.ProtobufSerializer
import com.google.protobuf.empty.Empty
import io.grpc.testing.integration.messages._
import scala.concurrent.Future


import akka.stream.Materializer

object @{service.name}AkkaGrpc {

  import @{service.name}.Serializers._

  def stub(channel: Channel): @{service.name}Stub = new @{service.name}Stub(channel)

  class @{service.name}Stub(channel: Channel, options: CallOptions = CallOptions.DEFAULT) extends @{service.name} {
    @for(method <- service.methods) {
    val @{method.name}Descriptor: MethodDescriptor[@method.inputTypeUnboxed, @method.outputTypeUnboxed] =
      MethodDescriptor.newBuilder()
        .setType(MethodDescriptor.MethodType.@{method.methodType.toString})
        .setFullMethodName(MethodDescriptor.generateFullMethodName("@service.grpcName", "@method.grpcName"))
        .setRequestMarshaller(new Marshaller(@method.deserializer.name))
        .setResponseMarshaller(new Marshaller(@method.serializer.name))
        .build()

    def @{method.name}(in: @method.parameterType): @method.returnType = {
      @if(method.methodType == akka.http.grpc.Unary) {
        Grpc.guavaFuture2ScalaFuture(
                ClientCalls.futureUnaryCall(channel.newCall(@{method.name}Descriptor, options), in))
      } else {
        ???
      }
    }
    }
  }

 class Marshaller[T <: com.trueaccord.scalapb.GeneratedMessage](u: ProtobufSerializer[T]) extends io.grpc.MethodDescriptor.Marshaller[T] {

    override def parse(stream: InputStream): T = {
      val baos = new ByteArrayOutputStream(math.max(64, stream.available()))
      val buffer = new Array[Byte](32 * 1024)

      var bytesRead = stream.read(buffer)
      while (bytesRead >= 0) {
        baos.write(buffer, 0, bytesRead)
        bytesRead = stream.read(buffer)
      }
      u.deserialize(akka.util.ByteString(baos.toByteArray))
    }

    override def stream(value: T): InputStream = {
      new InputStream with KnownLength {
        val bytes = value.toByteArray
        val bais: ByteArrayInputStream = new ByteArrayInputStream(bytes)
        override def read(): Int = bais.read()
        override def available(): Int = bytes.length
      }
    }
  }
}