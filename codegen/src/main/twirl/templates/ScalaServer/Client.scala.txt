@(service: akka.http.grpc.Service)

package @service.packageName

import akka.stream.scaladsl.Source
import akka.http.grpc.GuavaConverters
import io.grpc._
import io.grpc.stub.ClientCalls
import com.google.protobuf.empty.Empty
import io.grpc.testing.integration.messages._
import akka.stream.Materializer
import scala.concurrent.{ ExecutionContext, Future }
import @{service.name}Client._
import akka.http.grpc.Marshaller

class @{service.name}Client(channel: Channel, options: CallOptions)(implicit ex: ExecutionContext) extends @{service.name} {

  @for(method <- service.methods) {
  def @{method.name}(in: @method.parameterType): @method.returnType = {
  @if(method.methodType == akka.http.grpc.Unary) {
    GuavaConverters.toScalaFuture(
      ClientCalls.futureUnaryCall(channel.newCall(@{method.name}Descriptor, options), in)
    )
  } else {
    ???
  }
  }
  }
}


@mapMethodType(methodType: akka.http.grpc.MethodType) = {
  @if(methodType == akka.http.grpc.Unary) {
  MethodDescriptor.MethodType.UNARY
  }
  @if(methodType == akka.http.grpc.ClientStreaming) {
  MethodDescriptor.MethodType.CLIENT_STREAMING
  }
  @if(methodType == akka.http.grpc.ServerStreaming) {
  MethodDescriptor.MethodType.SERVER_STREAMING
  }
  @if(methodType == akka.http.grpc.BidiStreaming) {
  MethodDescriptor.MethodType.BIDI_STREAMING
  }
}

object @{service.name}Client {

  import @{service.name}.Serializers._

  def apply(channel: Channel)(implicit ex: ExecutionContext) =
    new @{service.name}Client(channel, CallOptions.DEFAULT)(ex)


  @for(method <- service.methods) {
  val @{method.name}Descriptor: MethodDescriptor[@method.inputTypeUnboxed, @method.outputTypeUnboxed] =
    MethodDescriptor.newBuilder()
      .setType(@mapMethodType(method.methodType))
      .setFullMethodName(MethodDescriptor.generateFullMethodName("@service.grpcName", "@method.grpcName"))
      .setRequestMarshaller(new Marshaller(@method.deserializer.name))
      .setResponseMarshaller(new Marshaller(@method.serializer.name))
      .build()
  }

}
