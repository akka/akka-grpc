package akka.grpc.interop

import akka.stream.{Materializer, SystemMaterializer}
import akka.http.scaladsl.model._
import akka.http.scaladsl.model.headers.RawHeader
import akka.http.scaladsl.server.RouteResult.Complete
import akka.http.scaladsl.server.{Directive0, Directives, Route}

import io.grpc.testing.integration.TestServiceHandlerFactory
import io.grpc.testing.integration.test.TestService
import org.scalatest.WordSpec

import scala.collection.immutable

// Generated by our plugin
import io.grpc.testing.integration.test.TestServiceHandler

class GrpcInteropIoWithAkkaSpec extends GrpcInteropTests(IoGrpcJavaServerProvider, AkkaHttpClientProviderScala)

class GrpcInteropAkkaScalaWithIoSpec extends GrpcInteropTests(AkkaHttpServerProviderScala, IoGrpcJavaClientProvider)
class GrpcInteropAkkaScalaWithAkkaSpec extends GrpcInteropTests(AkkaHttpServerProviderScala, AkkaHttpClientProviderScala)

class GrpcInteropAkkaJavaWithIoSpec extends GrpcInteropTests(AkkaHttpServerProviderJava, IoGrpcJavaClientProvider)
class GrpcInteropAkkaJavaWithAkkaSpec extends GrpcInteropTests(AkkaHttpServerProviderJava, AkkaHttpClientProviderScala)

object AkkaHttpServerProviderScala extends AkkaHttpServerProvider {
  import Directives._

  val label: String = "akka-grpc server scala"
  val pendingCases = Set()

  val server = AkkaGrpcServerScala(implicit sys => {
    implicit val ec = sys.dispatcher

    val requestHandler = TestServiceHandler(new TestServiceImpl())

    val route: Route = (pathPrefix(TestService.name) & echoHeaders) { ctx =>
      requestHandler(ctx.request).map(Complete)
    }

    Route.toFunction(Route.seal(route))
  })

  val echoHeaders: Directive0 = extractRequest.flatMap(request => {
    val initialHeaderToEcho = request.headers.find(_.name() == "x-grpc-test-echo-initial")
    val trailingHeaderToEcho = request.headers.find(_.name() == "x-grpc-test-echo-trailing-bin")

    mapResponseHeaders(h => h ++ initialHeaderToEcho) & mapTrailingResponseHeaders(h => h ++ trailingHeaderToEcho)
  })

  // TODO to be moved to the runtime lib (or even akka-http itself?)
  def mapTrailingResponseHeaders(f: immutable.Seq[HttpHeader] => immutable.Seq[HttpHeader]): Directive0 =
    mapResponse(response =>
      response.entity match {
        case HttpEntity.Chunked(contentType, data) =>
          response.withEntity(
            HttpEntity.Chunked(
              contentType,
              data.map {
                case chunk: HttpEntity.Chunk => chunk
                case last: HttpEntity.LastChunk =>
                  HttpEntity.LastChunk(last.extension, f(last.trailer))
              }))
        case _ =>
          val origTrailers = response
            .attribute(AttributeKeys.trailer)
            .map(_.headers)
            .getOrElse(Vector.empty)
            .map(e => RawHeader(e._1, e._2))
          response.addAttribute(AttributeKeys.trailer, Trailer(f(origTrailers)))
      })
}

object AkkaHttpServerProviderJava extends AkkaHttpServerProvider {
  val label: String = "akka-grpc server java"

  val pendingCases =
    Set(
      "custom_metadata"
    )

  val server = new AkkaGrpcServerJava((mat, sys) => {
    TestServiceHandlerFactory.create(new JavaTestServiceImpl(mat), sys)
  })
}

object AkkaHttpClientProviderScala extends AkkaClientProvider {
  val label: String = "akka-grpc scala client tester"

  def client = AkkaGrpcClientScala(settings => implicit sys => new AkkaGrpcClientTester(settings))
}
